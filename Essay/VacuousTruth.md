# Vacuous Truth (공허참)

명제 A이면 B이다에 대해, 전제 A가 거짓인 경우, 'A이면 B이다'라는 명제가 참이되는 현상을 의미한다.

## 예시

'모든 유니콘은 날 수 있다.'라는 명제가 있다고 하자. 현실에는 유니콘이 없기 때문에 '모든 유니콘은 날 수 있다.'도 '모든 유니콘은 헤엄칠 수 있다.'도 모두 참이 된다.

### 배경에 따른 양상의 변화

물론 유니콘이 존재하는 현실을 가정해서 만들 수도 있기 때문에, 어떤 배경 상황을 가정하는지에 따라 '모든 유니콘은'이라는 전제는 참이 될 수도 거짓이 될 수도 있다.

프로그래밍에서 유니콘이라는 클래스를 만들고 객체로 유니콘을 생산했다면 이는 존재하는 유니콘이라 볼 수 있을 것이다. 하지만 현실 세계를 배경으로 한다면 유니콘은 존재하지 않는 대상이 되므로 논리의 전개 양상이 달라진다.

일반적으로 인간의 사유는 일반적인 관념을 베이스로 하거나 현실에 기초한 생각을 하기 마련이다.

유니콘의 경우 일반적으로 통용될 수 있는 개념이기 때문에, '모든 유니콘은 날 수 있다.'라는 전제를 참으로 받아 들이는 사람이 있을 수 있다. 하지만 현실을 기반으로 생각하는 사람은 유니콘은 현실상 존재하지 않는 대상이기 때문에 '모든 유니콘은'이라는 전제는 실제 사례가 없는 것으로 볼 것이다.

## 전제와 결론의 참 거짓

명제 A이면 B이다에 대해 A와 B 각각에 참과 거짓을 부여할 수 있을끼? 명제 자체에는 참, 거짓을 부여할 수 있지만, A, B가 명제가 아니라, 유니콘, 날다 라는 개념인 경우, 참과 거짓을 어떻게 부여할 수 있을까? 이는 사례가 있는지 없는지에 대한 것으로 구별한다. 해당 대상이 원소로 존재하는 집합을 상정하는 것이 가능한지 아닌지에 따라서 공집합이면 존재하지 않는 것으로 거짓, 공집합이 아니면 존재하는 것으로 참으로 볼 수 있다.

좀 더 엄격하게 '모든 유니콘은 날 수 있다.'라는 명제에 대해, '유니콘', '날다'는 각각 '유니콘은 존재한다'라는 명제와 각각의 유니콘에 대해 날 수 있다와 날수 없다를 구별할 수 있는 술어 함수 f(x)를 만드는 것인데, x는 유니콘과 같은 대상을 판별할 수 있는 원소이고, f는 '날다'는 개념이 성립하는 함수로 보는 것이다.

## 직관의 위배

'하나님은 인간을 사랑하신다.'라는 문장이 있다고 해 보자. 사람에 따라 하나님이란 개념이 존재하는지 존재하지 않는지 저마다의 의견을 가질 것이다. 만약 하나님이 존재하지 않는다는 믿음을 가질 경우에는 '하나님은 인간을 사랑하신다.' 문장은 참이된다. 무신론자들에게 있어서 이 명제는 거짓이 되어야 하는데 참이 되기 때문에 직관을 위배하게 된다. 그런데, 전제를 거짓이라고 할 때, '하나님은 인간을 사랑하지 않으신다.'라는 말도 참이 되기 때문에 이는 참 거짓으로 따질 필요가 없는 무의미한 문장이 되는 것이다.

## 명제의 해석 방식

명제의 해석에 관해서 사람이 취할 수 있는 입장은 다양하다.

- (A) 명제의 전제가 거짓일 때는 명제는 참도 거짓도 아니라고 판단하는 쪽

- (B) 명제의 전제가 거짓이면 명제는 무조건 참이 된다는 쪽
  - (B1) 명제의 전제가 거짓이면 무조건 참이 되기 때문에 무의미하다는 쪽
  - (B2) 명제의 전제가 거짓이면 무의미하다고 판단하지 않고 참으로 판단해야 한다는 쪽

- (C) 명제의 전제가 거짓이면 명제가 거짓이 된다는 쪽
- (D) 전제가 거짓이면 논리적 추론이 불가능한 것으로 보고 추론 가능한 명제로서의 가치가 없다고 보는 쪽
- (E) 전제가 거짓이면 미확정 등의 특수한 상태로 판별하여 참 거짓 이외의 추가적인 진리값을 추가하여 논리를 전개하는 쪽

수리 논리에서는 B2를 사용한다.

D는 고전 논리에서 취하는 입장이다.

## 자연 언어적 논리와 수리 논리

기본적으로 수리 논리에서는 분류의 B의 방식을 사용하는데 이는 명제를 집합이론과 연관시키기 때문이다.

전제를 하나의 집합(X)으로 보고, 결론을 하나의 집합(Y)으로 볼 때 다음 두 케이스 중 하나를 만족하면 명제가 성립한다고 할 수 있다.

- X이면 Y이다.라는 명제는 X가 Y의 부분집합인 경우 (집합론적 해석)
- 정의역 X의 모든 원소에 대해 어떤 술어(f)를 만족하는 모든 치역이 Y인 경우 (술어 논리적 해석)

### 수리 논리의 양상

위의 집합론적 해석, 술어 논리적 해석 이외에 수리 논리에서는 다음과 같은 몇 가지 방식의 논리 해석 방식이 있다.

- 고전 명제 논리 : 진리표에 따라서 진리를 전개하는 것으로, 정해진 체계를 따라서 추론되는 것으로 인간의 이해와 동떨어진 논리 전개가 이뤄질 수 있다. 이를 해결하기 위해서, 인간의 이해를 벗어나는 명제가 구성된다면 이를 진리표 체계내에서 추론할 수 있는 명확한 형태로 바꾸어야 한다. 이를 위해 논리 사아의 빈 틈을 매꾸고, 명제의 논리가 어색한 부분을 분해하고 정확하게 구성해야 한다.
- 모형론적 해석 : 수리 논리학의 주류 해석 방식으로, 집합론적 해석과 술어 논리적 해석 모두를 사용하면서, 모델 Vacuous Truth (공허참)

명제 A이면 B이다에 대해, 전제 A가 거짓인 경우, 'A이면 B이다'라는 명제가 참이되는 현상을 의미한다.

## 예시

'모든 유니콘은 날 수 있다.'라는 명제가 있다고 하자. 현실에는 유니콘이 없기 때문에 '모든 유니콘은 날 수 있다.'도 '모든 유니콘은 헤엄칠 수 있다.'도 모두 참이 된다.

### 배경에 따른 양상의 변화

물론 유니콘이 존재하는 현실을 가정해서 만들 수도 있기 때문에, 어떤 배경 상황을 가정하는지에 따라 '모든 유니콘은'이라는 전제는 참이 될 수도 거짓이 될 수도 있다.

프로그래밍에서 유니콘이라는 클래스를 만들고 객체로 유니콘을 생산했다면 이는 존재하는 유니콘이라 볼 수 있을 것이다. 하지만 현실 세계를 배경으로 한다면 유니콘은 존재하지 않는 대상이 되므로 논리의 전개 양상이 달라진다.

일반적으로 인간의 사유는 일반적인 관념을 베이스로 하거나 현실에 기초한 생각을 하기 마련이다.

유니콘의 경우 일반적으로 통용될 수 있는 개념이기 때문에, '모든 유니콘은 날 수 있다.'라는 전제를 참으로 받아 들이는 사람이 있을 수 있다. 하지만 현실을 기반으로 생각하는 사람은 유니콘은 현실상 존재하지 않는 대상이기 때문에 '모든 유니콘은'이라는 전제는 실제 사례가 없는 것으로 볼 것이다.

## 전제와 결론의 참 거짓

명제 A이면 B이다에 대해 A와 B 각각에 참과 거짓을 부여할 수 있을끼? 명제 자체에는 참, 거짓을 부여할 수 있지만, A, B가 명제가 아니라, 유니콘, 날다 라는 개념인 경우, 참과 거짓을 어떻게 부여할 수 있을까? 이는 사례가 있는지 없는지에 대한 것으로 구별한다. 해당 대상이 원소로 존재하는 집합을 상정하는 것이 가능한지 아닌지에 따라서 공집합이면 존재하지 않는 것으로 거짓, 공집합이 아니면 존재하는 것으로 참으로 볼 수 있다.

좀 더 엄격하게 '모든 유니콘은 날 수 있다.'라는 명제에 대해, '유니콘', '날다'는 각각 '유니콘은 존재한다'라는 명제와 각각의 유니콘에 대해 날 수 있다와 날수 없다를 구별할 수 있는 술어 함수 f(x)를 만드는 것인데, x는 유니콘과 같은 대상을 판별할 수 있는 원소이고, f는 '날다'는 개념이 성립하는 함수로 보는 것이다.

## 직관의 위배

'하나님은 인간을 사랑하신다.'라는 문장이 있다고 해 보자. 사람에 따라 하나님이란 개념이 존재하는지 존재하지 않는지 저마다의 의견을 가질 것이다. 만약 하나님이 존재하지 않는다는 믿음을 가질 경우에는 '하나님은 인간을 사랑하신다.' 문장은 참이된다. 무신론자들에게 있어서 이 명제는 거짓이 되어야 하는데 참이 되기 때문에 직관을 위배하게 된다. 그런데, 전제를 거짓이라고 할 때, '하나님은 인간을 사랑하지 않으신다.'라는 말도 참이 되기 때문에 이는 참 거짓으로 따질 필요가 없는 무의미한 문장이 되는 것이다.

## 명제의 해석 방식

명제의 해석에 관해서 사람이 취할 수 있는 입장은 다양하다.

- (A) 명제의 전제가 거짓일 때는 명제는 참도 거짓도 아니라고 판단하는 쪽

- (B) 명제의 전제가 거짓이면 명제는 무조건 참이 된다는 쪽
  - (B1) 명제의 전제가 거짓이면 무조건 참이 되기 때문에 무의미하다는 쪽
  - (B2) 명제의 전제가 거짓이면 무의미하다고 판단하지 않고 참으로 판단해야 한다는 쪽

- (C) 명제의 전제가 거짓이면 명제가 거짓이 된다는 쪽
- (D) 전제가 거짓이면 논리적 추론이 불가능한 것으로 보고 추론 가능한 명제로서의 가치가 없다고 보는 쪽
- (E) 전제가 거짓이면 미확정 등의 특수한 상태로 판별하여 참 거짓 이외의 추가적인 진리값을 추가하여 논리를 전개하는 쪽

수리 논리에서는 B2를 사용한다.

D는 고전 논리에서 취하는 입장이다.

## 자연 언어적 논리와 수리 논리

기본적으로 수리 논리에서는 분류의 B의 방식을 사용하는데 이는 명제를 집합이론과 연관시키기 때문이다.

전제를 하나의 집합(X)으로 보고, 결론을 하나의 집합(Y)으로 볼 때 다음 두 케이스 중 하나를 만족하면 명제가 성립한다고 할 수 있다.

- X이면 Y이다.라는 명제는 X가 Y의 부분집합인 경우 (집합론적 해석)
- 정의역 X의 모든 원소에 대해 어떤 술어(f)를 만족하는 모든 치역이 Y인 경우 (술어 논리적 해석)

### 수리 논리의 양상

위의 집합론적 해석, 술어 논리적 해석 이외에 수리 논리에서는 다음과 같은 몇 가지 방식의 논리 해석 방식이 있다.

- 고전 명제 논리 : 진리표에 따라서 진리를 전개하는 것으로, 정해진 체계를 따라서 추론되는 것으로 인간의 이해와 동떨어진 논리 전개가 이뤄질 수 있다. 이를 해결하기 위해서, 인간의 이해를 벗어나는 명제가 구성된다면 이를 진리표 체계내에서 추론할 수 있는 명확한 형태로 바꾸어야 한다. 이를 위해 논리와 논리 사이의 빈 틈을 매꾸고, 명제의 논리가 어색한 부분을 분해하고 정확하게 구성해야 한다.

- 모형론적 해석 : 명제는 모든 케이스에 대해서 성립하는 것 보다는 일정한 범위와 규칙이 정해진 상태에서 성립한다. 이런 기술을 갖는 수리적 범위나 규칙을 모형이라고 하고, 해당 모형 내에서 명제의 추론과 전개를 하는 것이 모형론적 해석이다. 집합론적 해석이나 술어 논리적 해석을 어떤 모형 내에서 기술하는 것이 현대 수리 논리학의 일반적인 방식이다.

- 증명론적 해석 : 유클리드 기하학은 공리(전제)로 부터 풍부한 명제들을 증명할 수 있다. 다양한 양상을 증명할 수 있는 논리 체계를 갖추는 것이 중요하며, 무언가를 증명하기에 부실한 체계를 가지고 있다면 증명론적 해석을 위한 가치가 떨어지는 체계를 가진 것으로 풍부한 대상을 증명할 수 있는 체계 속에서의 논리 전개를 중요시한다.

## 공허참의 수리적 해석

공허참은 전제가 거짓일 때 명제가 참이 되는 현상이다. 수리 논리적으로 전제가 거짓이라는 것은 전제를 집합으로 보고, 해당 집합을 만족하는 원소가 하나도 없는 경우, 공집합인 경우 공허참이 되는 현상이다.

수리논리적으로 명제의 성립은 집합론적 해석이나 술어 논리적 해석이 충족 되어야 한다.
- 집합론적 관점에서 보면, 전제가 공집합인 경우 전제는 항상 결론 집합에 포함되기 때문에 추론은 항상 참이 된다.
- 술어 논리적 관점에서 보면, 전제가 공집합인 경우 공집합을 정의역으로 하는 술어(f)를 만족하는 치역의 원소는 공집합이 된다. 술어를 만족하지 않는 치역도 공집함이며 술어를 만족하지 않는 치역이 공집합이라면 반례가 존재하지 않는다. 반례가 존재하지 않는다는 것은 일단은 명제가 틀렸다고 할 수 없다는 것이며, 공집합인 정의역에 대응되는 치역이 공집합이라는 것으로 대응하는 요소가 없는 것으로 대응되는 요소가 없다면 정의역과 치역 사이의 술어가 성립되지 않는다고 볼 수 없기 때문에 성립된다는 귀류법적인 직관에 따라 참으로 받아들인다. (참으로 받아들이지 않는 해석의 양상이 존재할 수 있지만, 수리 논리적으로는 일단은 참으로 간주된다.)

## 프로그래밍에서의 해석

프로그래밍에서 요소가 없는 빈 컬렉션이 주어졌을 때 그 어떤 원소도 술어함수를 만족하지 않는 상태에서 true를 반환해야 할까? false를 반환해야 할까?

컬렉션은 판별 가능한 대상을 가지고 있고, all은 각각의 요소들이 판별 함수에 의해 판별 되었을 때 모두가 true가 될 경우이다.

기본적으로 조건문은 긍정일 때 블록 내의 코드를 실행한다. 물론 부정문일 때 실행하는 경우도 많지만, 특별한 이유가 없는 한 긍정문일 때 코드를 실행한다.

조건문에 all 메소드를 사용하는 것은 모든 요소가 판별 함수를 만족할 때 실행하는 의도로 자주 사용된다. 이는 두 가지로 의미로 해석될 수 있는데, 주어진 모든 요소가 판별 함수를 만족할 때 실행한다는 의미와 주어진 요소 중 어느 하나라도 반례가 존재하면 실행하지 않겠다는 의미이다.

전자의 경우 (모든 요소가 판별 함수를 만족할 때 실행) 빈 컬렉션은 만족하는 대상이 없으므로 false를 반환하는 것이 되며,

후자의 경우 (요소들 중 판별 함수를 만족하지 않는 것이 하나라도 존재) 빈 컬렉션은 반례가 하나도 없므으로 true를 반환하는 것이 된다.

프로그래밍을 할 때 두 가지 모두 의미상으로 문제가 없다. 다만, 컬렉션의 요소가 가변적일 때, 요소를 하나씩 늘리거나 줄이는 경우 일관적으로 true가 되기 위해서는 모든 요소가 판별 함수를 만족해야 한다. 모든 요소가 판별 함수를 만족하고 있었는데, 컬렉션에 요소가 존재하다가 없어지는 경우 어느 요소도 판별 함수에 의해 잘못된 것이 없음에도 불구하고 false가 되는 것은 일관성이 없다.

컬렉션의 요소에서 어느 하나라도 false인 경우 all 메소드의 반환 값은 false가 된다. 요소를 늘리거나 줄여도 이 경우는 all 메소드의 반환값은 false이다. 만약 빈 컬렉션이 되어 판별 함수를 만족하지 않는 요소가 사라졌다면 false의 요인이 되는 요소가 사라지는데 false로 하는 게 맞을까? 그리고 컬렉션에 값이 존재하더라도 false가 되는 요소가 사라지면 all 메소드의 반환값은 true가 된다. 반례가 되는 요소가 사라졌을 때 all은 true를 반환하는 패턴이 있다면, 빈 컬렉션에 대해 반례가 되는 요소가 없어졌을 때 true를 반환하는 쪽이 일관성 있을 것이다.

컬렉션의 요소가 가변적인 측면을 생각했을 때의 규칙을 생각하면 빈 컬렉션의 경우 true를 반환하는 편이 일관성이 있고 패턴에 부합한다.

컬렉션의 요소 추가 제거의 관점에서 빈 컬렉션에 대한 all 메소드의 반환 값을 true로 하는 것은 요소의 변경 관점에서 일관성을 제공한다. 컬렉션의 요소가 고정되어 있거나 빈 컬렉션이 되지 않는 맥락에서는 빈 컬렉션이 되지 않으므로 all 메소드가 true를 반환하든 false를 반환하든 고려하지 않아도 된다.

빈 컬렉션이 될 수 있는 상황에서는 빈 컬렉션에 대한 all의 반환이 true가 되는 것은 의미 있지만, 빈 컬렉션이 될 수 없는 상황에서 빈 컬렉션에 대한 all의 반환은 고려할 필요가 없다.
